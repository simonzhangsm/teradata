## 数据仓库的基本概念
> 数据仓库 ，由数据仓库之父比尔·恩门（Bill Inmon）于1990年提出，主要功能仍是将组织透过资讯系统之联机交易处理(OLTP)经年累月所累积的大量资料，透过数据仓库理论所特有的资料储存架构，作一有系统的分析整理，以利各种分析方法如线上分析处理(OLAP)、数据挖掘(Data Mining)之进行，并进而支持如决策支持系统(DSS)、主管资讯系统(EIS)之创建，帮助决策者能快速有效的自大量资料中，分析出有价值的资讯，以利决策拟定及快速回应外在环境变动，帮助建构商业智能(BI)。

&emsp;&emsp;总的来说，数据仓库有以下几个特点：
    1. 面向主题的
    2. 集成的
    3. 包含历史的和随时间变化的数据信息
    4. 资料一旦确认写入后是不会被取代或删除的，即使资料是错误的亦同

##  Teradata数据库设计思想  
&emsp;&emsp;Teradata公司的创建者在设计Teradata时主要希望Teradata能够达到以下目标：
    1. 并行处理能力。现在teradata是唯一一个能够并行载入数据、并行备份数据以及并行处理数据的数据库。
    2. 能够容纳1TB甚至更多的数据。
## Teradata数据库体系结构
&emsp;&emsp;Teradata之所以强大是因为它的并行处理能力，设计者们为Teradata设计了独特的体系结构。
&emsp;&emsp;Teradata数据库主要由PE、AMP以及BYNET三个模块组成模块：  
![Teradata体系结构](https://f.cloud.github.com/assets/2755931/1339477/10140096-3607-11e3-9af8-9a2e3642c7c8.jpg)


### 1. PE (Parsing Engine)  
&emsp;&emsp;用户登入teradata数据库时实际上是与PE相连，当用户提交一个查询请求时，PE监听到这个请求并设定一个执行流程，接着PE通知AMP执行相应的操作，并返回结果。PE几乎知道Teradata数据库的所有知识，如AMP数量、以及数据库表的相关信息，所以PE能够根据SQL语句制定最优的查询计划并交个AMP去执行。
&emsp;&emsp;另外，PE还负责安全检测和用户的权限检查，判断用户是否具有执行某个SQL语句的权限。   
### 2.AMP(Access Module Processor)    
&emsp;&emsp;每个AMP通过BYNET与PE相连，同时每个AMP有自己的磁盘。当收到PE的指令时，AMP从本地磁盘中读取数据，并通过BYNET将结构返回给PE。每个AMP只具有对本地磁盘的访问权限，不能访问与其他AMP相连的磁盘，这种架构称为“SHARED NOTHING ARCHITECTURE”。  
### 3.BYNET    
&emsp;&emsp;BYNET是Teradata内部用于连接PE和各个AMP的网络结构。Teradata内部含有两个BYNET网络，分别为"BYNET 0 "和"BYNET 1"。当有一个BYNET出现故障时，另外一个会接管服务。  

## Teradata数据放置方式  
&emsp;&emsp;Teradata数据库采用哈希(Hashing)算法作为其唯一的数据分配机制。它将表的主索引作为哈希算法的输入值，并且利用一个矩阵结构的HASH MAP，将哈希运算计算出来的输出值通过此矩阵与系统中的各个AMP进行映射。HASH MAP中的元素称为HASH BUCKET，每个BUCKET保存某个AMP的编号。这样，通过HASH MAP就可以将一条记录“引导”到相应的AMP上进行操作。  
&emsp;&emsp;目前，Teradata数据库的HASP MAP矩阵共有65536个BUCKETS。在Teradata数据库中，一个经哈希算法处理后的输出是一个取值范围在0-2^32之间的32比特整数，称为ROW HASH值。它进一步分成两部分，前16比特就是对应HASH MAP的HASH BUCKET，其取值范围为0-65535。当用户向数据库插入一条记录时，Teradata利用哈希算法根据记录的主索引计算出ROW HASH值，通过HASH MAP找到相对应的AMP，则该条记录即通过此AMP存放到其管理的磁盘上。由于主索引值的不同和哈希算法的均匀性，一个表的各条记录将均匀地分布到系统中各个AMP所管理的磁盘上。  
数据分配过程完全自动进行，不需要DBA干预，这一点和其它OLTP数据库有很大的区别。  
&emsp;&emsp;我们用一个实际的例子来说明数据分配过程。考虑下面插入一条记录的SQL语句：   
        INSERT INTO order Values (7550, 16, 950420, ’0’);   


&emsp;&emsp;分析引擎PE接受到此交易请求后，首先检查数据字典，确定表ORDER的主索引是第一个字段，由此可知上述记录的主索引值是7550。通过哈希算法对7550进行计算，其输出是一个32比特的 ROW HASH，假设结果为001AD6C7，故HASH BUCKET为001A。通过此HASH BUCKET在HASH MAP中映射，对应的处理器是AMP 3。换言之，上述记录
将交给AMP 3处理，AMP 3将这条数据插入到本地磁盘中。

![hash1](https://f.cloud.github.com/assets/2755931/1357677/94efe020-379f-11e3-8d73-f84555decb6f.GIF)

&emsp;&emsp;概括来说，Teradata是以记录而非表为单位来存储数据的。这样，一个表的各条记录将均匀分散在系统中所有磁盘上，不存在“热盘”问题。而且这个过程自动进行，不需要数据库管理员的干预，不需要对磁盘作固定分区(如把某个表固定在某个磁盘区域)。  
## Teradata的线性可扩展性   
&emsp;&emsp;Teradata最吸引人的地方之一是它的线性可扩展性，任何时候如果想将数据库的性能翻倍，只需将AMP的数量翻倍就行了。Teradata将每个数据库表中的记录平均保存在各个AMP上，每个AMP保存一个数据库表的部分记录。  
&emsp;&emsp;假设一个employee表包含8条记录，Teradata包含两个AMP，则数据的放置方式如下所示：
![2-amp](https://f.cloud.github.com/assets/2755931/1357522/1a9cfa88-379a-11e3-8a6c-533aaf439427.jpg)  
&emsp;&emsp;当PE发出请求需要查询employee表的所有信息时，两个AMP将同时访问本地的磁盘读取4条记录返回给PE。假设AMP读取每条数据需要1MS，则整个查询时间需要4MS。  
若想要将查询速度加倍，只需再增加一倍的AMP数量，并重新对数据进行布局，最后的数据方式放置如下：  
![4-amp](https://f.cloud.github.com/assets/2755931/1357571/1511c736-379c-11e3-8fdd-0520d254d00a.jpg)

&emsp;&emsp;此时若要想获取整个employee表的记录，则只需要每个AMP 2MS的时间，整个查询速度降低了一半。  
扩展过程中涉及到数据的重新分配。对于大部分数据库来说，要完成这种工作必须先把数据库系统中的所有数据都备份出来，然后对新系统进行重新划分分区，然后再加载数据，整个过程非常麻烦且极易丢失数据，数据库管理员的工作量也很大。  
而对于teradata数据库来说，这个过程是非常简单的，完全不需要将数据备份出来。数据库管理员只需要在增加必要的硬件设备之后简单地运行一个CONFIG/RECONFIG工具，就可以在系统中增加2个新的AMP，以管理新增的磁盘。同时，系统将重新自动计算新的HASH MAP，以映射到新增的AMP，哈希算法本身不需要作任何调整。新的HASH MAP生成后，数据库中原有的数据将在此基础上重新进行分配。  
经过计算，如果一条记录仍应存储在原来的磁盘单元中，则不需要移动；如果一条记录主索引产生的BUCKET所对应的AMP是新增加的两个AMP之一，则它将被重新分配到新AMP所管理的存储单元中。极大地减少了系统升级的时间，也极大地减轻了数据库管理员的工作强度。  
## Teradata索引机制    
### 主索引
&emsp;&emsp;在Teradata数据库中只有一种基于哈希算法的数据分配机制，数据的分配是依靠对主索引进行哈希处理来完成的。因此，必须在创建表的同时就确定主索引。如果在创建表时不明确指定主索引，Teradata数据库将把第一个非空字段当成缺省的主索引，以便进行数据的分配，如果选择的字段取值不是唯一的，则可能导致数据在各个AMP上分配不均与。因此，Teradata数据库要求在创建表的同时必须明确指定主索引，而数据库管理员最重要的工作就是为每张数据表选择尽可能唯一的字段来作主索引。  
### 哈希冲突与不唯一主索引  
&emsp;&emsp;前面谈到，哈希算法的输出范围从0到2^32。这虽然是一个很大的范围，但毕竟是有限的。因此一定有机会产生这样的现象：即不同的输入值经哈希算法处理后得到相同的结果。这被称为哈希冲突。另外一种情况是：如果选定的主索引是NUPI(非唯一主索引)，其值不唯一，那么两条记录如果具有相同的主索引值，则产生的ROW HASH一定是一样的。  
为了把一个表中的各条记录区为开来，必须考虑如何处理上面谈到的哈希冲突和NUPI的问题。为此，Teradata数据库给每个ROW HASH 自动指定和维护一个32 比特的唯一值(Unique Value)，它与ROW HASH组合起来，构成一个唯一的记录标识号(ROW ID)。  
![1-nusi](https://f.cloud.github.com/assets/2755931/1357806/75042068-37a5-11e3-8df1-c75f39a8e672.GIF)


## Teradata数据库访问机制   
### 基于主索引的数据访问机制  
&emsp;&emsp;下面结合例子对这种访问机制进行说明    
![PI](https://f.cloud.github.com/assets/2755931/1358337/be96e884-37bc-11e3-85b9-d1c71639027f.PNG)

&emsp;&emsp;当PE接收到到图中的SQL交易请求后，PE解析器从数据字典中找到对应表的标识号，同时通过数据字典来检查WHERE条件字句中的匹配项是否是主索引。当确认是主索引后，将此索引值进行哈希处理，得到一个32比特的ROW HASH。将表标识号、ROW HASH值以及主索引值本身一起在BYNET上广播， 每个AMP都能收到此广播信息，但只有一个与ROW HASH中的BUCKET对应的AMP才会执行数据库读操作。该AMP利用ROW HASH和表标识号一起来定位数据块，将其读入内存。然后在内存中根据记录标识号(ROW ID)来定位具体的数据记录，查询结果依照原来的路径返回给前端。  
由此可见，基于主索引的查询是一种单步AMP操作(One AMP Operation)，因此速度非常快。  

### 基于唯一次索引USI的数据访问  
&emsp;&emsp;当分析引擎PE接收到一个SQL查询请求，并判断出WHERE条件子句中的匹配字段是一个唯一次索引时，就会采取基于USI的数据访问策略。  
![usi_visit](https://f.cloud.github.com/assets/2755931/1358370/a684e2a4-37bd-11e3-9348-e1eda4acdfa9.PNG)

&emsp;&emsp;首先，分析引擎PE接收到SQL交易请求后，利用数据字典判断出WHERE条件子句中的匹配条件客户编号(Cust)是一个USI，因此，先对此USI值进行哈希处理，处理后的ROW HASH值为602。同时，从数据字典中找到客户表的标识号为100。PE把这两个值连同客户编号的值一起在BYNET上广播，以便确定由哪个AMP
来搜索相应的USI子表。从HASH MAP中可以确定是AMP 2，该AMP利用从BYNET中得到的信息迅速从USI子表中定位数据块。  
&emsp;&emsp;我们看到，在USI子表中只有三个子段，即针对USI计算出来的记录标识号(ROW ID)、USI值本身和针对主索引在主表中计算出来的记录标识号。注意ROW ID是由ROW HASH和一个数据库系统自动维护的唯一值组成的。从USI子表中定
位数据块后，可以从中找到主索引对应的ROW ID，由此得到主索引的ROW HASH 值为778，系统赋的唯一值为7。Teradata将它们连同表标识号100再次在BYNET上广播，通过HASH MAP可以确定是AMP 4，该AMP利用上面得到的ROW ID可以直接从主表中定位数据记录。  
&emsp;&emsp;根据上面的分析可以得出这样的结论：和主索引一样，唯一次索引也是一种指针，只不过主索引直接指向记录的存储位置，而唯一次索引则是指向主索引对应的记录标识号，它相当于指向指针的指针。  
利用唯一次索引进行的数据访问是一种双AMP操作(Two AMP Operation)，并且这两次操作都不需要对全表进行搜索，因此速度很快。这就是建立唯一次索引能提高系统查询速度的原因。当然，付出的代价是增加了一个基于USI的子表，对它的存储和自动维护都需要耗费系统一定的资源。  

### 基于非唯一次索引NUSI的数据访问  
&emsp;&emsp;当一个次索引的值不具有唯一性时，它就是一个非唯一次索引NUSI(Non-Unique Secondary Index)。那么，基于NUSI进行的数据访问过程又是怎样的呢？它能否提高系统的查询处理速度呢？  
![nusi_visit2](https://f.cloud.github.com/assets/2755931/1358416/5539213c-37c0-11e3-8c15-ffc1de9d9a69.PNG)


&emsp;&emsp;分析引擎PE从客户端接收到SQL交易请求后，用分解器对其分解。从数据字典中判断出SQL语句的WHERE条件子句中的匹配字段是一个非唯一次索引NUSI，于是采取基于NUSI的数据访问策略。先对此NUSI值"Adams"作哈希处理，得出ROW HASH值为567。又从数据字典中确定表标识号为100，连同NUSI值一起在BYNET上广播。  
**Teradata数据库对NUSI的处理与USI不一样，NUSI子表与相应的主表用同一个AMP进行存储和维护。在进行数据访问时虽然也将NUSI值进行哈希处理，但结果的HASH BUCKET被忽略，不用来决定由哪个AMP进行NUSI匹配。**Teradata 将ROW HASH、NUSI值本身、和表标识号对所有AMP广播，让每个AMP在各自的NUSI子表中寻找匹配的数据。因此，所有AMP将同时操作，在各自的NUSI子表中定位相应的数据块，但只有AMP 1和AMP 2中找到了匹配的数据。和USI一样，在NUSI的子表中也只有三个子段：针对NUSI计算出来的记录标识号(ROW ID)、NUSI值本身和针对主索引在主表中计算出来的记录标识号。AMP 1在其负责的NUSI子表中找到一条匹配ROW HASH值567(NUSI值"Adams"的ROW HASH结果)的记录，其对应的主索引的记录标识号为"638, 1"，即主索引的ROW HASH值为638，系统赋的唯一值为1。同样，AMP 2在其负责的NUSI子表中找到两条匹配的记录，其对应的主索引的记录标识号分别为"471, 1"和 "717, 2"，即主索引的ROW HASH值分别为471和717，系统赋的唯一值分别为1和2。   
&emsp;&emsp;上述信息连同表标识号100和NUSI值"Adams"再次在BYNET上广播，通过HASH MAP的映射，由AMP 1和AMP 2在主表中直接定位相应的数据记录。    
综上所述，基于非唯一次索引NUSI的数据访问是一种牵涉到所有AMP的操作(All AMP Operation)。它分成两步进行：首先在NUSI子表中根据对NUSI值的哈希处理结果在NUSI子表中寻找主索引的ROW HASH值，然后进一步在主表中来寻找匹 配的数据记录。这两个步骤分别依靠NUSI的ROW HASH和主索引的ROW HASH值 直接定位相应的数据块，不需要对全表进行搜索，因此速度也是很快的。   
和唯一次索引的作用一样，非唯一次索引也可以看成是一个指向指针的指针。建立NUSI同样可以提高数据访问的速度，所付出的代价则是增加了一个基于NUSI的子表，对它的存储和自动维护同样需要耗费系统一定的资源。  
### 全表扫描  
&emsp;&emsp;上面分别讨论了基于主索引、唯一次索引、和非唯一次索引进行的数据访问过程。它们的速度都很快，但前提条件则是：客户所提交的查询请求必须基于索引进行。对于OLTP系统而言，由于交易类型简单而且固定，我们完全可以针对定义好的问题建立相应的索引。但对数据仓库系统来说，其基本的特征之一就是所谓的动态查询(Ad-Hoc Query)。由于市场、环境等各方面因素的变化，我们不能把所有的业务问题都预先描述出来，因此也无法预先建立相应的索引。另外，有相当多的问题本身就无法基于索引来处理，如对表进行统计、排序，或在WHERE条件子句中包含LIKE、BETWEEN运算符等等。这些问题在OLTP系统中不多，但却是决策支持应用的一个基本特征。对于这些问题必须采用全表扫描(Full Table Scan，简称FTS)的数据处理方式。下面就来讨论一下全表扫描的过程。  
&emsp;&emsp;全表扫描对数据库系统的并行处理能力要求非常高，而这正是Teradata数据库的强项。我们知道，在Teradata数据库中，一个表的所有记录是根据主索引通过哈希算法处理后利用HASH MAP均匀地分配到各个AMP所负责的存储单元中。  
&emsp;&emsp;当分析引擎PE接收到一个针对客户表的查询请求后，它首先决定采取什么样的搜索策略。如果不能采取前面几节讨论的基于索引的数据搜索方法，它就采用全表扫描的方法进行处理。  
因此，对于一个复杂的查询任务，当需要使用全表扫描时，这个任务被分成了许多个子任务并分派给系统中的所有AMP来完成，每个AMP只需要在它所负责的存储单元中搜索到符合条件的数据记录，最后在BYNET一级汇总后返回即可。这样，总的处理时间就是各AMP中最慢一个所花的时间，而不是所有AMP处理时间的和。    












































































